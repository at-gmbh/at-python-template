# trigger on pull requests needs to be set manually in Azure DevOps
trigger: none

pool:
  name: Azure Pipelines
  vmImage: ubuntu-latest

jobs:

- job: Test
  variables:
    VENV_FOLDER: $(Pipeline.Workspace)/venv
    {%- if cookiecutter.package_manager == 'pip' %}
    PIP_CACHE_DIR: $(Pipeline.Workspace)/venv/lib
    {%- elif cookiecutter.package_manager == 'conda' %}
    CONDA_ENV_NAME: test-env
    CONDA_PKGS_DIRS: /usr/share/miniconda/envs/$(CONDA_ENV_NAME)
    {%- elif cookiecutter.package_manager == 'poetry' %}
    POETRY_VERSION: 1.6
    # we have to cache the whole folder in order to activate the env later on
    # otherwise the activate binary isn't restored for a cache hit
    POETRY_CACHE_DIR: $(System.DefaultWorkingDirectory)/.venv
    {%- endif %}
    PACKAGE_NAME: '{{ cookiecutter.project_slug }}'

  steps:
  - checkout: self

  - task: UsePythonVersion@0
    displayName: Use Python 3.8
    inputs:
      versionSpec: 3.8
      addToPath: true

  - task: Bash@3
    displayName: Install system dependencies
    inputs:
      targetType: inline
      script: |
        set -uex
        sudo apt update
        sudo apt install -y build-essential

  # fill in or delete if no Azure Keyvault is used
  - task: AzureKeyVault@1
    inputs:
      azureSubscription: ''
      KeyVaultName: ''
      SecretsFilter: ''
      RunAsPreJob: false

  {%- if cookiecutter.package_manager == 'pip' %}

  - task: Cache@2
    inputs:
      key: 'pip | venv | $(Agent.OS) | requirements.txt | requirements-dev.txt'
      path: $(PIP_CACHE_DIR)
    displayName: Cache pip packages

  - task: Bash@3
    displayName: Create venv
    inputs:
      targetType: inline
      script: |
        set -uex
        python -m venv $(VENV_FOLDER)
        source $(VENV_FOLDER)/bin/activate

  - task: Bash@3
    displayName: Setup environment
    inputs:
      targetType: inline
      script: |
        set -uex
        source $(VENV_FOLDER)/bin/activate
        # resolve issues with old cached versions of pip
        # Open question: Still needed?
        python -m pip install --upgrade pip || (curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py && python get-pip.py)
        python -m pip install wheel

        # install python app dependencies
        python -m pip install -r requirements.txt -r requirements-dev.txt -U

        # build and install wheel
        python setup.py dist
        python -m pip install --force-reinstall dist/*.whl

  - task: Bash@3
    displayName: pytest (with coverage)
    # define env variables as needed
    env:
      PACKAGE_NAME: $(PACKAGE_NAME)
    inputs:
      targetType: inline
      script: |
        set -uex
        source $(VENV_FOLDER)/bin/activate

        # run pytest
        python -m pytest tests --doctest-modules --junitxml=junit/test-results.xml --cov=$PACKAGE_NAME --cov-report=xml:coverage-reports/cov.xml --cov-report=html
  {% elif cookiecutter.package_manager == 'conda' %}

  - task: Cache@2
    displayName: Cache conda packages
    inputs:
      key: 'conda | $(Agent.OS) | environment.yml | environment-dev.yml'
      path: $(CONDA_PKGS_DIRS)
      cacheHitVar: CONDA_CACHE_RESTORED

  - task: Bash@3
    displayName: Create conda environment
    inputs:
      targetType: inline
      script: |
        set -uex
        conda env create -n $(CONDA_ENV_NAME) -f environment-dev.yml environment.yml
        source /usr/share/miniconda/etc/profile.d/conda.sh
        conda activate $(CONDA_ENV_NAME)
        python -m pip install wheel
    condition: eq(variables.CONDA_CACHE_RESTORED, 'false')

  - task: Bash@3
    displayName: Install project as python package
    inputs:
      targetType: inline
      script: |
        set -uex
        source /usr/share/miniconda/etc/profile.d/conda.sh
        conda activate $(CONDA_ENV_NAME)
        python setup.py dist
        python -m pip install --force-reinstall dist/*.whl

  # run tests with coverage information
  - task: Bash@3
    displayName: pytest (with coverage)
    # define env variables as needed
    env:
      PACKAGE_NAME: $(PACKAGE_NAME)
    inputs:
      targetType: inline
      script: |
        set -uex
        source /usr/share/miniconda/etc/profile.d/conda.sh
        conda activate $(CONDA_ENV_NAME)
        python -m pytest tests --doctest-modules --junitxml=junit/test-results.xml --cov=$PACKAGE_NAME --cov-report=xml:coverage-reports/cov.xml --cov-report=html
  {% elif cookiecutter.package_manager == 'poetry' %}

  - task: Cache@2
    displayName: Cache poetry packages
    inputs:
      key: 'poetry | $(Agent.OS) | pyproject.toml '
      path: $(POETRY_CACHE_DIR)
      cacheHitVar: POETRY_CACHE_RESTORED

  - task: Bash@3
    displayName: Configure poetry
    inputs:
      targetType: inline
      script: |
        set -uex
        pip install poetry==$(POETRY_VERSION)

  - task: Bash@3
    displayName: Create venv
    inputs:
      targetType: inline
      script: |
        set -uex
        poetry install --no-root
        source `poetry env info --path`/bin/activate
    condition: eq(variables.POETRY_CACHE_RESTORED, 'false')

  # run tests with coverage information
  - task: Bash@3
    displayName: pytest (with coverage)
    inputs:
      targetType: inline
      script: |
        set -uex
        # install root which obviously shouldn't be cached
        poetry install --only-root
        source `poetry env info --path`/bin/activate
        python -m pytest tests --doctest-modules --junitxml=$(System.DefaultWorkingDirectory)/junit/test-results.xml --cov=src/'{{ cookiecutter.module_name }}' --cov-report=xml:$(System.DefaultWorkingDirectory)/coverage-reports/cov.xml --cov-report=html:$(System.DefaultWorkingDirectory)/coverage-reports/cov.html

  {%- endif %}
  - task: PublishCodeCoverageResults@1
    displayName: Publish code coverage
    inputs:
      codeCoverageTool: Cobertura
      summaryFileLocation: $(System.DefaultWorkingDirectory)/coverage-reports/cov.xml
      additionalCodeCoverageFiles: $(System.DefaultWorkingDirectory)/junit/
    condition: succeededOrFailed()

  # publish pytest results
  - task: PublishTestResults@2
    inputs:
      testResultsFormat: JUnit
      testResultsFiles: $(System.DefaultWorkingDirectory)/**/*-results.xml
      testRunTitle: Publish pytest results
      failTaskOnFailedTests: false
    condition: succeededOrFailed()
